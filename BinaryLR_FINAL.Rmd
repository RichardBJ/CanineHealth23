---
title: "R stats for binary logistic regression on SIGNIFICANT or SERIOUS illness"
author: "Alex German"
date: "7 December 2023"
output:
  html_document:
    df_print: paged
  word_document: default
  html_notebook: default
---


# Create data frame for analysis

### NB need to run "Read_data_101.RMD" first to create dataset
```{r include=FALSE}
knitr::knit("Read_data_101.rmd")
```


# LET'S DO SOME INTIAL TABULATION AND CHI SQUARE TESTS

## Tabulate D_Sex + D_Neuter + D_Diet
```{r 1}
## three way cross tabs (xtabs) and flatten the table
ftable(xtabs(~ D_Sex + D_Neuter + D_Diet, data = ml))
```

## Tabulate D_Neuter + D_Diet
```{r 2}
## two way cross tabs (xtabs) and flatten the table
ftable(xtabs(~ D_Neuter + D_Diet, data = ml))
```

## Tabulate C_Diet_Vegan + D_Diet_Vegan
```{r 3}
## two way cross tabs (xtabs) and flatten the table
ftable(xtabs(~ C_Diet_Vegan + D_Diet_Vegan, data = ml))
```

# Tabulate C_Diet_Vegan_Veggie + D_Diet_Vegan_Veggie
```{r 4}
## two way cross tabs (xtabs) and flatten the table
ftable(xtabs(~ C_Diet_Vegan_Veggie + D_Diet_Vegan_Veggie, data = ml))
```


## Tabulate D_Sex, D_Neuter and D_Raw
```{r 5}
## three way cross tabs (xtabs) and flatten the table
ftable(xtabs(~ D_Sex + D_Neuter + D_Diet_Raw, data = ml))
```


## Tabulate D_Neuter and D_Raw
```{r 6}
## two way cross tabs (xtabs) and flatten the table
ftable(xtabs(~ D_Neuter + D_Diet_Raw, data = ml))
```


## Chi squared test of C_VEGAN vs D-VEGAN
```{r 7}

table(ml$C_Diet_Vegan, ml$D_Diet_Vegan)
chisq.test(ml$C_Diet_Vegan, ml$D_Diet_Vegan, correct=FALSE)
```


## Chi squared test of NEUTERED vs D-RAW
```{r 8}

table(ml$D_Neuter, ml$D_Diet_Raw)
chisq.test(ml$D_Neuter, ml$D_Diet_Raw, correct=FALSE)
```


## Tabulate Health_Binary and Income
```{r I57}
## three way cross tabs (xtabs) and flatten the table
ftable(xtabs(~ Health_Binary + Income, data = ml))
```


## Chi squared test of Health_Binary and Income
```{r I58}

table(ml$Health_Binary, ml$Income)
chisq.test(ml$Health_Binary, ml$Income, correct=FALSE)
```





# BINARY LOGISTIC REGRESSION ON SIGNIFICANT OR SERIOUS ILLNESS
## CHECK EFFECT OF OWNER CHARACTERISTICS - simple binary logistic regression

## CLIENT DIET binary regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r 9g}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ C_Diet, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### check assumptions of model
#### Cook's distance
```{r 10g}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r 11g}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r 1g2}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r 13g}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### Calculate Nagelkerke R^2
```{r g}
NagelkerkeR2(m)
```

### Create ROCR for training and test data
```{r ROC1}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC1}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## CLIENT DIET VEGAN binary regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r 9}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ C_Diet_Vegan, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r 9a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r 10}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r 11}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r 12}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r 13}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### Calculate Nagelkerke R^2
```{r}
NagelkerkeR2(m)
```


### Create ROCR for training and test data
```{r ROC2}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC2}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```





## C_Diet_Vegan_Veggie Binary logistic regression for HEALTH
```{r I84}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ C_Diet_Vegan_Veggie, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r I84a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I85}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I86}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I87}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I88}
model.data %>% 
  filter(abs(.std.resid) > 3)
```


### Create ROCR for training and test data
```{r ROC3}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC3}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```




## LOCATION binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I9}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Location, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
glmtoolbox::hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r I9a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I10}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I11}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I12}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I13}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC4}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC4}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## SETTING binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I14}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ setting, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
glmtoolbox::hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r I14a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I15}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I16}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I17}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I18}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC5}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC5}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## URBAN binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I19}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Urban, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r I19a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I20}
plot(m, which = 4, id.n = 3)
```

# Extract model results and display data for top 3 values using Cook's distance
```{r I21}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I22}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I23}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC6}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC6}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```




## LOCATION + URBAN binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I24}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Location + Urban, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r I24a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I25}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I26}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I27}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I28}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r I29}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC7}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC7}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## LOCATION * URBAN binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I30}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Location*Urban, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r I30a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I31}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I32}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I33}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I34}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r I35}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC8}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC8}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## EDUCATION Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I37}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Education, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r I37a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I38}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I39}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I40}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I41}
model.data %>% 
  filter(abs(.std.resid) > 3)
```


### Create ROCR for training and test data
```{r ROC9}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC9}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## EDUCATION_S Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I42}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Education_S, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m, G=3)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r I42a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I43}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I44}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I45}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I46}
model.data %>% 
  filter(abs(.std.resid) > 3)
```


### Create ROCR for training and test data
```{r ROC10}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC10}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```


## EDUCATION_S2 Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I42i}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Education_S2, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m, G=3)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r I42ai}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I43i}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I44i}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I45i}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I46i}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC11}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC11}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## ANIMAL CAREER 2 Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I47}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Animal_Career2, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r I47a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I48}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I49}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I50}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

# Filter potential influential data points with abs(.std.res) > 3:
```{r I51}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC12}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC12}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## ANIMAL_CAREER_BINARY Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I52}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Animal_Career_BINARY, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)

## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r I52a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I53}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I54}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I55}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I56}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC13}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC13}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```




## INCOME Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I59}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Income, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
glmtoolbox::hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r I59a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I60}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I61}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I62}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I63}
model.data %>% 
  filter(abs(.std.resid) > 3)
```


### Create ROCR for training and test data
```{r ROC14}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC14}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```




## INCOME2 Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I59i}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Income2, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
glmtoolbox::hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r I59ai}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I60i}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I61i}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I62i}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I63i}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC15}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC15}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## C_AGE Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I64}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ C_Age, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m, G=4)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r I64a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I65}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I66}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I67}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I68}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC16}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC16}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## C_AGE2 Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I64i}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ C_Age2, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m, G=4)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


## Calculate Nagelkerke R^2
```{r I64ai}
NagelkerkeR2(m)
```

## check assumptions of model
#### Cook's distance
```{r I65i}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I66i}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I67i}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I68i}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC17}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC17}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## C_GENDER Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I69}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ C_Gender, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r I69a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I70}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I71}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I72}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I73}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC18}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC18}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



# NOW CHECK ASSOCIATIONS BETWEEN SIGNIFICANT OR SERIOUS ILLNESS AND DOG CHARACTERISTICS - simple BINARY LOGISTIC regression


## DOG DIET VEGAN binary regression for ON SIGNIFICANT OR SERIOUS ILLNESS
```{r 14t}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Diet_Vegan, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r 14at}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r 15t}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r 16t}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r 17t}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r 18t}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC19}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model mtt
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC19}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```





## DOG DIET VEGAN_VEGGIE binary regression for ON SIGNIFICANT OR SERIOUS ILLNESS
```{r 14tx}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Diet_Vegan_Veggie, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r 14atx}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r 15tx}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r 16tx}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r 17tx}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r 18tx}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC20}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC20}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## DOG DIET binary regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r 14it}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Diet, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r 14ati}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r 15ti}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r 16ti}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r 17ti}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r 18ti}
model.data %>% 
  filter(abs(.std.resid) > 3)
```


### Create ROCR for training and test data
```{r ROC21}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC21}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```


## CLIENT DIET VEGAN + DOG DIET VEGAN binaryl regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r 25sq}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ C_Diet_Vegan + D_Diet_Vegan, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
glmtoolbox::hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r 25asq}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r 26sq}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r 27sq}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r 28sq}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r 29sq}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r 30sq}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC22}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC22}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## CLIENT DIET VEGAN * DOG DIET VEGAN binaryl regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r 25s}
# fit binary logit model and store results 'm2'
m <- glm(Health_Binary ~ C_Diet_Vegan*D_Diet_Vegan, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
glmtoolbox::hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r 25as}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r 26s}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r 27s}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r 28s}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r 29s}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r 30s}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC23}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC23}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## DOG DIET RAW binary regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r 32d}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Diet_Raw, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r 32ad}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r 33d}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r 34d}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

# plot standardised residuals
```{r 35d}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r 36d}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC24}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC24}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## DOG DIET + CLIENT DIET binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r 78}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Diet + C_Diet , data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m, G=7)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r 78a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r 79}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r 80}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r 81}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r 82}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r 89}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC25}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC25}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## THERAPEUTIC DIET binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r 90}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Therapeutic_Food, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)

## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r 90a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r 91}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r 92}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r 93}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r 94}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC26}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC26}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```




## DOG DIET + THERAPEUTIC DIET binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r 95}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Diet + Therapeutic_Food, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m, G=3)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r 95a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r 96}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r 97}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r 98}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r 99}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r I1}
car::vif(m)
```


### Create ROCR for training and test data
```{r ROC27}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC27}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## DOG DIET * THERAPEUTIC DIET binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I2}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Diet*Therapeutic_Food, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m, G=7)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r I2a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I3}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I4}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I6}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I7}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
##### Note interactions
```{r I8}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC28}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC28}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```




## SIZE Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r I89}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Size, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r I2aq}
NagelkerkeR2(m)
```



### check assumptions of model
#### Cook's distance
```{r I90}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I91}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I92}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I93}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC29}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC29}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## SIZE2 Binary logistic regression for HEALTH
```{r I89i}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Size2, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r I89iii}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I90i}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I91i}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I92i}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I93i}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC30}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC30}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## SIZE_GIANT Binary logistic regression for HEALTH
```{r I89ii}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Size_Giant, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)

## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r I89iv}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r I90ii}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I91ii}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I92ii}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I93ii}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC31}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC31}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## D_AGE Binary logistic regression for HEALTH
```{r I94}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Age, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```

### Calculate Nagelkerke R^2
```{r I94a}
NagelkerkeR2(m)
```

### Check age is linear with logit of outcome
##### Note lack of linearity
```{r I95}
ypred = predict(m)
res = residuals(m, type = 'deviance')
plot(ypred,res)
```

### Box Tidwell test to check that D_Age is linearly associated with the logit of the outcome
##### suggests not linear
```{r I96}
boxTidwell(ml$Health_Binary ~ ml$D_Age)
```

### check assumptions of model
#### Cook's distance
```{r I97}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I98}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I99}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I100}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC32}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model mtt
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC32}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## D_AGE Binary logistic regression for HEALTH with splines
```{r I94q}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ bs(D_Age, degree=1,df=2), data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r I94aq}
NagelkerkeR2(m)
```


### check assumptions of model
#### Cook's distance
```{r I97q}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r I98q}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r I99q}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r I100q}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC32q}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model mtt
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC32q}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```





## D_Age_quant logistic regression for HEALTH
#### Note better model fit that D_Age
```{r II1}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Age_quant, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m, G=4)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II1aa}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II1a}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II2}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II3}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II4}
model.data %>% 
  filter(abs(.std.resid) > 3)
```


### Create ROCR for training and test data
```{r ROC33}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC33}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## D_SEX Binary logistic regression for HEALTH
```{r II17}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Sex, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II17a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II18}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II19}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II20}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II21}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC34}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC34}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```




## DOG NEUTER binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r 37d}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Neuter, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r 37ad}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r 38d}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r 39d}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r 40d}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r 41d}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC35}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC35}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```




## D_SEX + D_NEUTER Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r II5}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Sex + D_Neuter, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II5a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II6}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II7}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II8}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II9}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r II10}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC36}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC36}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## D_SEX * D_NEUTER Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r II11}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ D_Sex*D_Neuter, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II11a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II12}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II13}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

# plot standardised residuals
```{r II14}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

# Filter potential influential data points with abs(.std.res) > 3:
```{r II15}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r II16}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC37}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC37}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



# CHECK EFFECT OF DOG HEALTH CHARACTERISTICS ON SIGNIFICANT OR SERIOUS ILLNESS - simple binary regression

## THERAPEUTIC FOOD Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r II27}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Therapeutic_Food, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)

## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II27a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II28}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II29}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II30}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II31}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC38}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC38}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```





## VISITS Binary logistic regression ON SIGNIFICANT OR SERIOUS ILLNESS
```{r II32}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Visits, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II32a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II33}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II34}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II35}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II36}
model.data %>% 
  filter(abs(.std.resid) > 3)
```


### Create ROCR for training and test data
```{r ROC39}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC39}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```


## VISITS2 Binary logistic regression for HEALTH
#### Note Visits better fit than Visits2
```{r II37}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Visits2, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II37a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II37aa}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II38}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II39}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II40}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC40}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC40}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## MEDS Binary logistic regression for HEALTH
```{r II41}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test

## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II41a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II42}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II43}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II44}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II45}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

### Create ROCR for training and test data
```{r ROC41}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC41}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



# MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
## ROUND 1: Model with all variables
```{r III32a, warning=FALSE}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Location + Urban + Education_S2 + Animal_Career_BINARY 
         + Income2 + C_Age2 + C_Gender + C_Diet + Size2 + D_Sex + D_Neuter  + D_Diet + Therapeutic_Food + Visits 
         + Meds + bs(D_Age, degree=1,df=2), data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)

## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III11abya}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III12bya}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III13bya}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III14bya}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III15bya}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III16bya}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC55bya}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC55bya}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```









# MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
## ROUND 2: Model with all variables
Remove Education as least significant in round 1
```{r III32b, warning=FALSE}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Location + Urban + Animal_Career_BINARY 
         + Income2 + C_Age2 + C_Gender + C_Diet + Size2 + D_Sex + D_Neuter  + D_Diet + Therapeutic_Food + Visits 
         + Meds + bs(D_Age, degree=1,df=2), data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)

## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III11abyb}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III12byb}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III13byb}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III14byb}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III15byb}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III16byb}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC55byb}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC55byb}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```







# MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
## ROUND 3: Model with all variables
Remove C_Age2 as least significant in round 2
```{r III32c, warning=FALSE}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Location + Urban + Animal_Career_BINARY 
         + Income2 + C_Gender + C_Diet + Size2 + D_Sex + D_Neuter  + D_Diet + Therapeutic_Food + Visits 
         + Meds + bs(D_Age, degree=1,df=2), data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)

## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III11abyc}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III12byc}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III13byc}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III14byc}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III15byc}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III16byc}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC55byc}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC55byc}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```







# MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
## ROUND 4: Model with all variables
Remove Income2 as least significant in round 3
```{r III32d, warning=FALSE}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Location + Urban + Animal_Career_BINARY 
         + C_Gender + C_Diet + Size2 + D_Sex + D_Neuter  + D_Diet + Therapeutic_Food + Visits 
         + Meds + bs(D_Age, degree=1,df=2), data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)

## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III11abyd}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III12byd}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III13byd}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III14byd}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III15byd}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III16byd}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC55byd}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC55byd}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```








# MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
## ROUND 5: Model with all variables
Remove C_Gender as least significant in round 4
```{r III32e, warning=FALSE}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Location + Urban + Animal_Career_BINARY 
         + C_Diet + Size2 + D_Sex + D_Neuter  + D_Diet + Therapeutic_Food + Visits 
         + Meds + bs(D_Age, degree=1,df=2), data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)

## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III11abye}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III12bye}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III13bye}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III14bye}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III15bye}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III16bye}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC55bye}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC55bye}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```







# MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
## ROUND 6: Model with all variables
Remove Urban as least significant in round 5
```{r III32f, warning=FALSE}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Location + Animal_Career_BINARY 
         + C_Diet + Size2 + D_Sex + D_Neuter  + D_Diet + Therapeutic_Food + Visits 
         + Meds + bs(D_Age, degree=1,df=2), data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)

## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III11abyf}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III12byf}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III13byf}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III14byf}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III15byf}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III16byf}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC55byf}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC55by}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```









# MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
## ROUND 7: Model with all variables
Remove D_Sex as least significant in round 6
```{r II46}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Location + D_Diet + Therapeutic_Food + Animal_Career_BINARY + C_Diet + bs(D_Age, degree=1,df=2) + Size2 + D_Neuter + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II46a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II47}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II48}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II49}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II50}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r II51}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC42}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC42}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



# MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
## ROUND 8: Remove D_Diet as least significant variable in round 7
```{r II52}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Location + Therapeutic_Food + Animal_Career_BINARY + C_Diet + Size2 + bs(D_Age, degree=1,df=2) + D_Neuter + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II52a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II53}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II54}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II55}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II56}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r II57}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC43}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC43}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



# MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
## ROUND 9: Remove C_Diet as least significant variable in round 8
```{r II58}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Location + Therapeutic_Food + Animal_Career_BINARY + Size2+ bs(D_Age, degree=1,df=2) + D_Neuter + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```




### Calculate Nagelkerke R^2
```{r II58a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II59}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II60}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II61}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II62}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r II63}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC44}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC44}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



# MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
## ROUND 10: Remove D_Neuter as least significant variable in round 9
```{r II64}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Location + Therapeutic_Food + Animal_Career_BINARY + Size2 + bs(D_Age, degree=1,df=2) + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II64a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II65}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II66}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II67}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II68}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r II68a}
car::vif(m)
```


### Create ROCR for training and test data
```{r ROC45}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC45}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



# MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
## ROUND 11: Try without Animal_Career_BINARY as least significant in round 10
```{r II46u}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Location + Therapeutic_Food + Size2 + bs(D_Age, degree=1,df=2) + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II46au}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II47u}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II48u}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II49u}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II50u}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r II51u}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC46}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC46}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```




# MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
## ROUND 12: Replace Size2 with Size_Giant to see if model fit improved
Confirm fit improved
```{r II69i}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Location + Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II69ai}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II70i}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II71i}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II72i}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II73i}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r II74i}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC47d}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC47d}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
### ROUND 13: Replace Location with Location_Europe to see if model fit improved
confirm fit improved
```{r II69ig}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Location_Europe + Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II69aig}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II70ig}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II71ig}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II72ig}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II73ig}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r II74ig}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC47g}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC47g}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```





## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
### ROUND 14: Try without location_europe as most are not significant
```{r II69ii}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II69aii}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II70ii}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II71ii}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II72ii}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

# Filter potential influential data points with abs(.std.res) > 3:
```{r II73ii}
model.data %>% 
  filter(abs(.std.resid) > 3)
```


# check for multicollinearity
```{r II74ii}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC48}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC48}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```





## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
### ROUND 15.  Remove Visits as least significant variable in round 14
```{r II75}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m, G=9)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II75a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II76}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II77}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II78}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II79}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r II80}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC49}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC49}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```


## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
Fit worse when visits removed, so keep this
### ROUND 16: Now try adding D_Diet back in
```{r II93}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Visits + Meds + D_Diet, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II93a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II94}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r II95}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r II96}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r II97}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r II98}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC52}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC52}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```


## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
### ROUND 17: Try adding D_Raw in instead
```{r II99}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~   Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Visits + Meds + D_Diet_Raw, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r II99a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r II100}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III1}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III2}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III3}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III4}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC53}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC53}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
### ROUND 18: OK, now try D_Diet_Vegan
```{r III5}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Visits + Meds + D_Diet_Vegan, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r III5a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III6}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III7}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III8}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III9}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III10}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC54}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC54}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
### ROUND 19: Try adding D_Diet_Vegan_Veggie back in
```{r III11}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Visits + Meds + D_Diet_Vegan_Veggie, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r III11a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III12}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III13}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III14}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III15}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III16}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC55}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC55}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
### ROUND 20: Try adding C_Diet back in
```{r III11b}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Visits + Meds + C_Diet, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r III11ab}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III12b}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III13b}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III14b}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III15b}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III16b}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC55b}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC55b}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```




## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
### ROUND 20: Try adding C_Diet_Vegan back in
```{r III11by}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Visits + Meds + C_Diet_Vegan, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r III11aby}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III12by}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III13by}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III14by}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III15by}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III16by}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC55by}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC55byx}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```





## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION
### SO THIS IS THE FINAL BEST FIT MODEL FOR BINARY LOGISTIC REGRESSION
```{r III17}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III17a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III18}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III19}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III20}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III21}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III22}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC57}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC57}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION BASED ON BIC
### SO THIS IS THE FINAL BEST FIT MODEL FOR BINARY LOGISTIC REGRESSION
#### just check that all variables are needed... first remove D_Age
```{r III23}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Therapeutic_Food + Size_Giant + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r III23a}
NagelkerkeR2(m)
```

### Create ROCR for training and test data
```{r ROC58}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC58}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION BASED ON BIC
### SO THIS IS THE FINAL BEST FIT MODEL FOR BINARY LOGISTIC REGRESSION
#### just check that all variables are needed... next remove Visits
```{r III24}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III24a}
NagelkerkeR2(m)
```

### Create ROCR for training and test data
```{r ROC59}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC59}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION BASED ON BIC
### SO THIS IS THE FINAL BEST FIT MODEL FOR BINARY LOGISTIC REGRESSION
### just check that all variables are needed... try removing Meds
```{r III25s}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Therapeutic_Food + Size_Giant + bs(D_Age, degree=1,df=2) + Visits, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III25as}
NagelkerkeR2(m)
```


### Create ROCR for training and test data
```{r ROC60s}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC60s}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION BASED ON BIC
### SO THIS IS THE FINAL BEST FIT MODEL FOR BINARY LOGISTIC REGRESSION
### just check that all variables are needed... try removing Size_Giant
Fit is better without Size_Giant
```{r III25x}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ Therapeutic_Food + bs(D_Age, degree=1,df=2) + Visits + Meds + Size_Giant, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III25ax}
NagelkerkeR2(m)
```


### Create ROCR for training and test data
```{r ROC60x}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC60x}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```



## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION BASED ON BIC
### SO THIS IS THE FINAL BEST FIT MODEL FOR BINARY LOGISTIC REGRESSION
### just check that all variables are needed... try removing Therapeutic_Food
```{r III25}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ bs(D_Age, degree=1,df=2) + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III25a}
NagelkerkeR2(m)
```


### Create ROCR for training and test data
```{r ROC60}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC60}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```




## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION BASED ON BIC
## SO THIS IS DEFINITELY THE FINAL BEST FIT MODEL FOR BINARY LOGISTIC REGRESSION
Fit is worse with therapeutic food in the model.
```{r III25z}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ bs(D_Age, degree=1,df=2) + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III26a}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III27}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III28}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III29}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III30}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III31}
car::vif(m)
```


### Create ROCR for training and test data

```{r ROC61}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```


### Report AUC from ROC for training and test data
```{r AUC61}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```


## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION BASED ON BIC
## SO THIS IS DEFINITELY THE FINAL BEST FIT MODEL FOR BINARY LOGISTIC REGRESSION
Fit is worse with therapeutic food in the model.
Last but not least, try adding D_Diet_Vegan back into the model
```{r III25zx}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ bs(D_Age, degree=1,df=2) + Visits + Meds + D_Diet_Vegan, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III26ax}
NagelkerkeR2(m)
```



#### check for multicollinearity
```{r III31x}
car::vif(m)
```


### Create ROCR for training and test data
```{r ROC61x}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```


### Report AUC from ROC for training and test data
```{r AUC61x}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```

# Create Figure of best fit model with D_Diet_Vegan added back
```{r bfmPlot2}
boxLabels = c("D_Age<6", "D_Age>6", "Visits 1", "Visits 2", "Visits 3","Visits 4+","Meds", "D_Diet_Vegan")
# Enter OR and CI data. boxOdds are the odds ratios, 
# boxCILow is the lower bound of the CI, boxCIHigh is the upper bound.
df <- data.frame(yAxis = length(boxLabels):1, 
                 boxOdds = c(1.684530680, 15.561941722, 0.520310039, 0.696594299, 
                             0.892359741, 5.044956747, 10.719663499, 0.861889500), 
                 boxCILow = c(0.4654385981, 3.4023614305, 0.0898854205, 0.1205638201, 
                              0.1275889949, 0.9716573376, 3.3430149950, 0.2372717597), 
                 boxCIHigh = c( 6.9596734, 75.0187071, 4.6254271, 6.3578629, 8.8877503, 
                                44.1647225, 47.3307313, 2.4697881))


# Plot
p <- ggplot(df, aes(x = boxOdds, y = boxLabels)) 

p + geom_vline(aes(xintercept = 1), size = .25, linetype = "dashed") +
  geom_errorbarh(aes(xmax = boxCIHigh, xmin = boxCILow), size = .5, height = 
                   .2, color = "gray50") +
  geom_point(size = 3.5, color = c("blue","red", "blue", "blue", "blue", "blue", "red","blue")) +
  theme_bw() +
  theme(panel.grid.minor = element_blank()) +
  scale_linewidth_binned() +
  scale_x_log10(limits = c(0.06,100), breaks = c(0.12, 0.25, 0.5, 1, 2, 4, 8, 16, 32, 64)) +
  ylab("") +
  xlab("\nOdds ratio (log scale)") +
  theme(axis.text = element_text(face="bold")) +
  theme(axis.title.x = element_text(face="bold")) +
  annotate(geom = "text", y =1.0, x = 24.0, label ="Model P < 0.001\nPseudo  R^2 = 0.342\nAUC = 0.904",
           size = 3.0, hjust = 0) + ggtitle("Binary logistic regression: significant illness") +
   theme(plot.title = element_text(hjust = 0.5))

ggsave("FigBR_SigSeriousILL2.TIFF")
```


## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION BASED ON BIC
## SO THIS IS DEFINITELY THE FINAL BEST FIT MODEL FOR BINARY LOGISTIC REGRESSION
Fit is worse when D_Diet Vegan is added back.
Now, try adding C_Diet Vegan back
```{r III25zy}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ bs(D_Age, degree=1,df=2) + Visits + Meds + C_Diet_Vegan, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III26ay}
NagelkerkeR2(m)
```

#### check for multicollinearity
```{r III31y}
car::vif(m)
```


### Create ROCR for training and test data
```{r ROC61y}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```


### Report AUC from ROC for training and test data
```{r AUC61y}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```


# Create Figure of best fit model with C_Diet_Vegan added back in
```{r bfmPlot3}
boxLabels = c("D_Age<6", "D_Age>6", "Visits 1", "Visits 2", "Visits 3","Visits 4+","Meds","C_Diet_Vegan")
# Enter OR and CI data. boxOdds are the odds ratios, 
# boxCILow is the lower bound of the CI, boxCIHigh is the upper bound.
df <- data.frame(yAxis = length(boxLabels):1, 
                 boxOdds = c(1.652369459, 14.653797792, 0.520704031, 0.710673922, 0.902028430, 
                             5.203039914, 10.739776844, 1.130307012), 
                 boxCILow = c(0.456331212, 3.177777551, 0.090469929 , 0.124600567, 0.130021224, 
                              1.018335971, 3.362859243, 0.485753455), 
                 boxCIHigh = c(6.83093319, 71.23096429, 4.61930743, 6.45041973, 8.94699032,
                               45.24732696, 47.11425073, 2.46299997))


# Plot
p <- ggplot(df, aes(x = boxOdds, y = boxLabels)) 

p + geom_vline(aes(xintercept = 1), size = .25, linetype = "dashed") +
  geom_errorbarh(aes(xmax = boxCIHigh, xmin = boxCILow), size = .5, height = 
                   .2, color = "gray50") +
  geom_point(size = 3.5, color = c("blue","red", "blue", "blue", "blue", "red", "red","blue")) +
  theme_bw() +
  theme(panel.grid.minor = element_blank()) +
  scale_linewidth_binned() +
  scale_x_log10(limits = c(0.06,100), breaks = c(0.12, 0.25, 0.5, 1, 2, 4, 8, 16, 32, 64)) +
  ylab("") +
  xlab("\nOdds ratio (log scale)") +
  theme(axis.text = element_text(face="bold")) +
  theme(axis.title.x = element_text(face="bold")) +
  annotate(geom = "text", y =1.0, x = 24.0, label ="Model P < 0.001\nPseudo  R^2 = 0.342\nAUC = 0.903",
           size = 3.0, hjust = 0) + ggtitle("Binary logistic regression: significant illness") +
   theme(plot.title = element_text(hjust = 0.5))

ggsave("FigBR_SigSeriousILL3.TIFF")
```


## MULTIPLE REGRESSION WITH BACKWARDS ELIMINATION BASED ON BIC
## DEFINITELY DEFINITELY DEFINITELY THE FINAL BEST FIT MODEL FOR BINARY LOGISTIC REGRESSION
Fit is worse with either D_Diet_Vegan or C_Diet_Vegan in the model
So,we have out final best-fit model
```{r III25zz}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~ bs(D_Age, degree=1,df=2) + Visits + Meds, data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```


### Calculate Nagelkerke R^2
```{r III26az}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III27z}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III28z}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III29z}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III30z}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III31z}
car::vif(m)
```


### Create ROCR for training and test data

```{r ROC61z}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```


### Report AUC from ROC for training and test data
```{r AUC61z}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```

# Create Figure of best fit model
```{r bfmPlot1}
boxLabels = c("D_Age<6", "D_Age>6", "Visits 1", "Visits 2", "Visits 3","Visits 4+","Meds")
# Enter OR and CI data. boxOdds are the odds ratios, 
# boxCILow is the lower bound of the CI, boxCIHigh is the upper bound.
df <- data.frame(yAxis = length(boxLabels):1, 
                 boxOdds = c(1.671945074, 15.20814445, 0.52257589, 0.706309471, 0.899533417, 5.14643563,
                             10.70922072), 
                 boxCILow = c(0.462524567, 3.359063004, 0.090659561, 0.123570422, 0.129369615, 1.006777174,
                              3.349448452), 
                 boxCIHigh = c(6.9012542, 72.5648772, 4.6379644, 6.420243, 8.9344745, 44.79383,
                               47.0856521))


# Plot
p <- ggplot(df, aes(x = boxOdds, y = boxLabels)) 

p + geom_vline(aes(xintercept = 1), size = .25, linetype = "dashed") +
  geom_errorbarh(aes(xmax = boxCIHigh, xmin = boxCILow), size = .5, height = 
                   .2, color = "gray50") +
  geom_point(size = 3.5, color = c("blue","red", "blue", "blue", "blue", "blue", "red")) +
  theme_bw() +
  theme(panel.grid.minor = element_blank()) +
  scale_linewidth_binned() +
  scale_x_log10(limits = c(0.06,100), breaks = c(0.12, 0.25, 0.5, 1, 2, 4, 8, 16, 32, 64)) +
  ylab("") +
  xlab("\nOdds ratio (log scale)") +
  theme(axis.text = element_text(face="bold")) +
  theme(axis.title.x = element_text(face="bold")) +
  annotate(geom = "text", y =1.0, x = 24.0, label ="Model P < 0.001\nPseudo  R^2 = 0.342\nAUC = 0.903",
           size = 3.0, hjust = 0) + ggtitle("Binary logistic regression: significant illness") +
   theme(plot.title = element_text(hjust = 0.5))

ggsave("FigBR_SigSeriousILL1.TIFF")
```




# Finally, let's try models with all variables
## Model with all variables including health-related variables (Visit, Meds and Therapeutic_Food)
NB replace Size2 with Size_Giant as mmodel would not converge
```{r III32, warning=FALSE}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Location + Urban + Education_S2 + Animal_Career_BINARY 
         + Income2 + C_Age2 + C_Gender + C_Diet + Size_Giant + D_Sex + D_Neuter  + D_Diet + Therapeutic_Food + Visits 
         + Meds + bs(D_Age, degree=1,df=2), data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)

## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint.default(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r III33}
NagelkerkeR2(m)
```

### check assumptions of model
#### Cook's distance
```{r III34}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III35}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III36}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III37}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III38}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC62}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC62}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```





# Create Figure of all-variable model ... Binary logistic regression on Significant or serious illness
```{r FigBR-anyHlth}

boxLabels = c("Location: Other European","Location: North America","Location: Australia/New Zealand/Oceania","Location: Other","Urban","Education_S1_College","Education_S2_Grad","Education_S3_PG_or_PhD","Animal_Career_Yes","Income_Medium","Income_High","C_Age_30-39","C_Age_40-49","C_Age_50-59","C_Age_60+","C_Gender_Male","C_Diet_Omnivore","C_Diet_Pescatarian","C_Diet_Vegan","C_Diet_Vegetarian", "Size_Giant", "D_Sex_Male","Neutered","D_Diet_Raw","D_Diet_Vegan","D_Diet_Vegetarian","Therapeutic food","Visits 1", "Visits 2", "Visits 3", "Visits 4+","Meds","D_Age<6","D_Age>6")
# Enter OR and CI data. boxOdds are the odds ratios, 
# boxCILow is the lower bound of the CI, boxCIHigh is the upper bound.
df <- data.frame(yAxis = length(boxLabels):1, 
                 boxOdds = c(2.329761405, 1.080307669, 2.13491272, 2.0882201, 0.766481225, 0.61255607,
                             1.070684657, 0.661543226, 1.383475891, 0.926160757, 0.697160975, 1.503355896,
                             0.721975137, 1.17828826, 0.594956909, 0.942243073, 1.270336775, 0.341010554,
                             1.169966054, 1.524892847, 6.735441359, 0.730978343, 0.730858228, 1.03902692,
                             0.48246902, 0.636344693, 1.936807791, 0.392632367, 0.554198487, 0.762390031,
                             4.37880728, 13.08981069, 1.646658063, 22.87764281), 
                 boxCILow = c(0.829279791, 0.238878463, 0.505868242, 0.348236739, 0.354855583, 0.20146737,
                              0.366547401, 0.22083027, 0.60274527, 0.348188878, 0.187485444, 0.493028277,
                              0.217635476, 0.360449261, 0.154987311, 0.184356567, 0.506318932, 0.056638258,
                              0.360061357, 0.486940222, 1.668285877, 0.361905582, 0.240161034, 0.445148239,
                              0.110456732, 0.048053821, 0.717241279, 0.056606526, 0.080492175, 0.094849662,
                              0.677253439, 3.404527342, 0.380545113, 3.771652251),
                 boxCIHigh = c(6.54518326, 4.88560017, 9.0099594, 12.52212275, 1.65558469, 1.86246011,
                               3.127469, 1.981791, 3.17547999, 2.46353, 2.59237952, 4.58407571, 2.39505116,
                               3.85175772, 2.28388841, 4.81578727, 3.18723125, 2.05317397, 3.80163142,
                               4.77532577, 27.1932832, 1.47643298, 2.22414828, 2.42520771, 2.10739854,
                               8.42668822, 5.23007324, 2.72336399, 3.81572451, 6.12799819, 28.31134121,
                               50.32802694, 7.12525974, 138.7685041))


# Plot
p <- ggplot(df, aes(x = boxOdds, y = boxLabels)) 
p + geom_vline(aes(xintercept = 1), size = .25, linetype = "dashed") +
  geom_errorbarh(aes(xmax = boxCIHigh, xmin = boxCILow), size = .5, height = 
                   .2, color = "gray50") +
  geom_point(size = 1.0, color = c("blue", "blue", "blue", "blue", "blue",
                                   "blue", "blue", "blue", "blue", "blue", "blue",
                                   "blue", "blue", "blue", "blue", "blue", "blue",
                                   "blue", "blue", "blue","red", "blue", "blue", "blue", "blue", "blue",
                                   "blue", "blue", "blue", "blue", "blue", "red", "blue",
                                   "red")) +
  theme_bw() +
  theme(panel.grid.minor = element_blank()) +
  theme(panel.grid.major = element_line(size = 0.25)) +
  scale_x_log10(limits = c(0.007, 150), breaks = c(0.015, 0.03, 0.06, 0.12, 0.25, 0.5, 1, 2, 4, 8, 16, 32, 64, 128)) +
  ylab("") +
  xlab("\nOdds ratio (log scale)") +
  theme(axis.text = element_text(face="bold")) +
    theme(axis.text.y = element_text(size = 4.0)) +
      theme(axis.text.x = element_text(size = 4.0)) +
  theme(axis.title.x = element_text(face="bold", size =6.0)) +
  annotate(geom = "text", y = 2, x = 14.0, label ="Model P < 0.001\nPseudo  R^2 = 0.403\nAUC = 0.890", size = 1.8, hjust = 0) +
  ggtitle("Binary logistic regression: significant illness") +
  theme(plot.title = element_text(hjust = 0.5, size = 8)) +
  theme(aspect.ratio= 1.25)


ggsave("FigBRSigSerAll.TIFF")
```




## Model with all variables but excluding health-related variables (Visit, Meds and Therapeutic_Food)
```{r III32y, warning=FALSE}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Location + Urban + Education_S2 + Animal_Career_BINARY 
         + Income2 + C_Age2 + C_Gender + C_Diet + Size_Giant + D_Sex + D_Neuter  + D_Diet +
         + bs(D_Age, degree=1,df=2), data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint.default(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r III33x}
NagelkerkeR2(m)
```


### check assumptions of model
#### Cook's distance
```{r III34x}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III35x}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III36x}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III37x}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III38x}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC63}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC63}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```


# Create Figure of owner-animal metadata model ... Binary logistic regression on Significnt or serious illness
```{r FigBR-anyHlthu}

boxLabels = c("Location: Other European","Location: North America","Location: Australia/New Zealand/Oceania","Location: Other","Urban","Education_S1_College","Education_S2_Grad","Education_S3_PG_or_PhD","Animal_Career_Yes","Income_Medium","Income_High","C_Age_30-39","C_Age_40-49","C_Age_50-59","C_Age_60+","C_Gender_Male","C_Diet_Omnivore","C_Diet_Pescatarian","C_Diet_Vegan","C_Diet_Vegetarian", "Size_Giant",  "D_Sex_Male","Neutered","D_Diet_Raw","D_Diet_Vegan","D_Diet_Vegetarian", "D_Age<6","D_Age>6")
# Enter OR and CI data. boxOdds are the odds ratios, 
# boxCILow is the lower bound of the CI, boxCIHigh is the upper bound.
df <- data.frame(yAxis = length(boxLabels):1, 
                 boxOdds = c(2.03200226, 1.33496073, 2.79917264, 3.03481434, 0.94266028, 0.69544406,
                             0.9901262, 0.85703501, 1.31564824, 0.91873564, 0.6577175, 1.38374221,
                             0.86394289, 0.98656915, 0.70242832, 0.54040644, 1.19905128, 0.64225887,
                             1.01124045, 1.23548338, 4.27908837, 0.78668695, 1.39384065, 0.65552115,
                             0.27943518, 0.67283678, 1.04364588, 21.64541079), 
                 boxCILow = c(0.81920456, 0.36745404, 0.85100804, 0.60484416, 0.48390516, 0.26215023,
                              0.38835383, 0.3223454, 0.64204441, 0.39339251, 0.20123519, 0.51625202,
                              0.29703457, 0.3452638, 0.21420861, 0.12806698, 0.53877013, 0.12507825,
                              0.36151659, 0.44907121, 1.40821831, 0.42651451, 0.55000672, 0.31642044,
                              0.07504288, 0.07552131, 0.27690469, 4.76183319),
                 boxCIHigh = c(5.0402957, 4.8499131, 9.2071603, 15.227225, 1.8363276, 1.8449056,
                               2.5243729, 2.2786397, 2.6959666, 2.145631, 2.1496852, 3.7089298,
                               2.5128297, 2.819058, 2.303388, 2.2803623, 2.6685295, 3.2979071,
                               2.8286592, 3.3990582, 13.0026695, 1.4510089, 3.5323055, 1.3580285,
                               1.0405254, 5.9944585, 3.9334716, 98.3914785))


# Plot
p <- ggplot(df, aes(x = boxOdds, y = boxLabels)) 
p + geom_vline(aes(xintercept = 1), size = .25, linetype = "dashed") +
  geom_errorbarh(aes(xmax = boxCIHigh, xmin = boxCILow), size = .5, height = 
                   .2, color = "gray50") +
  geom_point(size = 1.0, color = c("blue", "blue", "blue", "blue", "blue",
                                   "blue", "blue", "blue", "blue", "blue", "blue",
                                   "blue", "blue", "blue", "blue", "blue", "blue",
                                   "blue", "blue", "blue", "red", "blue", "blue",
                                   "blue", "blue", "blue", "blue", "red")) +
  theme_bw() +
  theme(panel.grid.minor = element_blank()) +
  theme(panel.grid.major = element_line(size = 0.25)) +
  scale_x_log10(limits = c(0.007, 150), breaks = c(0.015, 0.03, 0.06, 0.12, 0.25, 0.5, 1, 2, 4, 8, 16, 32, 64)) +
  ylab("") +
  xlab("\nOdds ratio (log scale)") +
  theme(axis.text = element_text(face="bold")) +
    theme(axis.text.y = element_text(size = 4.0)) +
      theme(axis.text.x = element_text(size = 4.0)) +
  theme(axis.title.x = element_text(face="bold", size =6.0)) +
  annotate(geom = "text", y = 2, x = 14.0, label ="Model P < 0.001\nPseudo  R^2 = 0.124\nAUC = 0.692", size = 1.8, hjust = 0) +
  ggtitle("Binary logistic regression: significant illness") +
  theme(plot.title = element_text(hjust = 0.5, size = 8)) +
  theme(aspect.ratio= 1.25)


ggsave("FigBRSigSerOwnAnim.TIFF")
```




## Model with all variables but excluding health-related variables (Visit, Meds and Therapeutic_Food) and D_Diet
```{r III32xys, warning=FALSE}
# fit binary logit model and store results 'm'
m <- glm(Health_Binary ~  Location + setting + Education_S2 + Animal_Career_BINARY 
         + Income2 + C_Age2 + C_Gender + C_Diet + Size_Giant + D_Sex + D_Neuter  + 
         + bs(D_Age, degree=1,df=2), data = ml_train,family = binomial)
# view a summary of the model
summary(m)
# test model fit
with(m, null.deviance - deviance)
with(m, df.null - df.residual)
with(m, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
BIC(m)
# Hosmer-Lemeshow Goodness-of-Fit Test
hltest(m)
## CIs using profiled log-likelihood
confint(m, level=0.99)
## CIs using standard errors
confint.default(m, level=0.99)
# Wald test
wald.test(b = coef(m), Sigma = vcov(m), Terms = 2)
## odds ratios and 95% CI
exp(cbind(OR = coef(m), confint(m, level=0.99)))
```



### Calculate Nagelkerke R^2
```{r III33xy}
NagelkerkeR2(m)
```


### check assumptions of model
#### Cook's distance
```{r III34xy}
plot(m, which = 4, id.n = 3)
```

#### Extract model results and display data for top 3 values using Cook's distance
```{r III35xy}
model.data <- broom::augment(m) %>% 
  mutate(index = 1:n()) 
model.data %>% top_n(3, .cooksd)
```

#### plot standardised residuals
```{r III36xy}
ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = Health_Binary), alpha = .5) +
  theme_bw()
```

#### Filter potential influential data points with abs(.std.res) > 3:
```{r III37xy}
model.data %>% 
  filter(abs(.std.resid) > 3)
```

#### check for multicollinearity
```{r III38xy}
car::vif(m)
```

### Create ROCR for training and test data
```{r ROC64}
## training data
pred.mtt = predict(m, type = "response") #repeat risk predictions from model m
rocr.pred.mtt = ROCR::prediction(pred.mtt, labels = ml_train$Health_Binary) #ROCR prediction object
roc.perf.mtt = ROCR::performance(rocr.pred.mtt, measure = "tpr", x.measure = "fpr") # #ROCR performance object
plot(roc.perf.mtt, col = "blue")


pred.te.1 = predict(m, newdata = ml_test, type = "response") #.te = "test"
rocr.pred.te.1 = ROCR::prediction(pred.te.1, labels = ml_test$Health_Binary)
roc.perf.te.1 = ROCR::performance(rocr.pred.te.1, measure = "tpr", x.measure = "fpr")
plot(roc.perf.te.1, col = "red", add = T)

abline(a = 0, b = 1, lty = 2) #diagonal for random assignment
legend("bottomright", legend = c("train","test"),
col = c("blue","red"), lty = c(2,1), lwd =1.5)
```

### Report AUC from ROC for training and test data
```{r AUC64}
  # Train AUC
aucTr <- ROCR::performance(rocr.pred.mtt, measure = "auc")
  aucTr <- aucTr@y.values[[1]]
  print(aucTr)
  
   # Test AUC
  aucTe <- ROCR::performance(rocr.pred.te.1, measure = "auc")
  aucTe <- aucTe@y.values[[1]]
  print(aucTe)
```







